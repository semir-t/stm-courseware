

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Introduction &mdash; STM32 Learning Material 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/drawio.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> STM32 Learning Material
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">Assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="hal.html">HAL API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">STM32 Learning Material</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/README.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>In this part of the course we will take a look at the ARM assembly intruction set and internal arhitecture of the ARM CPU.</p>
</div>
<div class="section" id="arm-32-registers">
<h1>ARM-32 Registers<a class="headerlink" href="#arm-32-registers" title="Permalink to this headline">¶</a></h1>
<p>For the purposes of the normal programmer in “User Mode” the ARM has 15 registers. R0-R12 are free for us to do whatever we want, R13 is the Stack Pointer (also addressable as SP), R15 is the Program Counter (PC)</p>
<p>R14 may be surprising to those familiar with other CPUs, when we call a subroutine (With BL - Branch and Link) the return address is not pushed onto the stack, instead it’s moved into R14/LR… to return from the subroutine we need to move the R14/LR register into R15/PC.</p>
<p>This poses a problem, as nesting subroutines will lose the return value, if this is needed, the best solution is to simply push R14/LR onto the stack at the start of a sub, and pop PC/R15 off the stack at the end.</p>
<p>|	| 	32 Bit registers	|	Use case		|
|—	|	—				|	—			|
|R0	|	R0				|				|
|R1	|	R1				|				|
|R2	|	R2				|				|
|R3	|	R3				|				|
|R4	|	R4				|				|
|R5	|	R5				|				|
|R6	|	R6				|				|
|R7	|	R7				|				|
|R8	|	R8				|				|
|R9	|	R9				|				|
|R10 |	R10				|				|
|R11 |	R11/FP			|Frame Pointer (Optional)				|
|R12 |	R12/IP			|Intra Procedure Call (Optional)		|
|R13 |	SP				|Stack Pointer				|
|R14 |	LR/LK			|Link register		|
|R15 |	PC				|System program counter				|</p>
<p>The Application Program Status Register (APSR) holds copies of the Arithmetic Logic Unit (ALU) status flags. They are also known as the condition code flags. They are used to determine whether conditional instructions are executed or not.</p>
<p><img alt="xPSR Register" src="_images/arm-xpsr-register.png" /></p>
<p>where</p>
<ul>
<li> <b>N</b> - Negative condition flag. Set to bit[31] of the result of the instruction. If the result is
regarded as a two's complement signed integer, then the processor sets N to 1 if the result
is negative, and sets N to 0 if it is positive or zero. </li>
<li> <b>Z</b> - Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A
result of zero often indicates an equal result from a comparison. </li>
<li> <b>C</b> - Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an
unsigned overflow on an addition. </li>
<li> <b>V</b> - Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for
example a signed overflow on an addition.</li>
<li> <b>Q</b> - Set to 1 to indicate overflow or saturation occurred in some instructions, normally related
to digital signal processing (DSP </li>
<li> <b>GE</b> - The Greater than or Equal flags</li>
</ul></div>
<div class="section" id="arm-instruction-set">
<h1>ARM Instruction set<a class="headerlink" href="#arm-instruction-set" title="Permalink to this headline">¶</a></h1>
<div class="section" id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>General syntax of the ARM instruction is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;&lt;</span><span class="n">cc</span><span class="o">&gt;&lt;</span><span class="n">S</span><span class="o">&gt;</span> 	<span class="n">Rd</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">operands</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where:</p>
<ul>
<li> <b>op</b> is ARM instruction </li>
<li> <b>cc</b> is compare flag </li>
<li> <b>S</b>  </li>
<li> <b>Rd</b> destination register </li>
<li> <b>operands</b> arguments for the instruction </li>
</ul><p>Following images describes format of the ARM instruction.
<img alt="ARM-Instruction-Format" src="_images/arm-instruction-format.png" /></p>
</div>
<div class="section" id="data-processing">
<h2>Data processing<a class="headerlink" href="#data-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mov">
<h3>MOV<a class="headerlink" href="#mov" title="Permalink to this headline">¶</a></h3>
<p>MOV instruction is used for loading the immediate value to register and for copying value from one register to another. Basic sytanx of the MOV instruction is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="n">destination</span><span class="p">,</span><span class="n">source</span>
</pre></div>
</div>
<p><b> Loading the immediate value</b></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span>  <span class="n">r0</span><span class="p">,</span><span class="c1">#0x1234			; load value 0x1234 to register r0</span>
<span class="n">mov</span>  <span class="n">r1</span><span class="p">,</span><span class="c1">#56				; load value 56 to register r1</span>
<span class="n">mov</span>  <span class="n">r2</span><span class="p">,</span><span class="c1">#0x12340000		; this will generate compiler error because we can only load 2 bytes using the MOV instruction</span>
</pre></div>
</div>
<p><b> Coppying value from one register to another </b></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="n">r0</span><span class="p">,</span><span class="n">pc</span>				<span class="p">;</span> <span class="n">this</span> <span class="n">will</span> <span class="n">coppy</span> <span class="n">value</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">PC</span>  <span class="n">to</span> <span class="n">register</span> <span class="n">r0</span>
</pre></div>
</div>
<p>/ref the above image. As we saw before, we can’t load to register immediate value greater than 2 bytes.   At least, we can’t achive this with only one instruction. But there is workaround. We can use left shift  to get desired value stored in the register. But this value that will be shifted must be stored in the internal register first.</p>
<p><b> Loading the immediate value larger then 2 bytes</b></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span>  <span class="n">r0</span><span class="p">,</span><span class="c1">#0x1234			; load value 0x1234 to register r0</span>
<span class="n">mov</span>  <span class="n">r1</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">LSL</span> <span class="mi">4</span>			<span class="p">;</span> <span class="n">load</span> <span class="n">value</span> <span class="mi">56</span> <span class="n">to</span> <span class="n">register</span> <span class="n">r1</span>
</pre></div>
</div>
</div>
<div class="section" id="mvn">
<h3>MVN<a class="headerlink" href="#mvn" title="Permalink to this headline">¶</a></h3>
<p>This instruction works just like the <strong>MOV</strong> instruction, but instead of loading the provided value to the destination register, this instruction will load first complement of the specified value. For example, instruction</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mvn</span> <span class="n">r0</span><span class="p">,</span><span class="c1">#0x00FF</span>
</pre></div>
</div>
<p>will load value <em>#0xff00</em> to the register <em>r0.</em></p>
</div>
<div class="section" id="add">
<h3>ADD<a class="headerlink" href="#add" title="Permalink to this headline">¶</a></h3>
<p>Basic sytanx of the ADD instruction is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add</span> 		<span class="n">r0</span><span class="p">,</span><span class="n">r1</span>		<span class="p">;</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">r1</span>
<span class="n">add</span> 		<span class="n">r0</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">r1</span> 	<span class="p">;</span> <span class="n">r0</span><span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">r1</span>
<span class="n">adc</span> 		<span class="n">r0</span><span class="p">,</span><span class="n">r1</span>		<span class="p">;</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">C</span>
</pre></div>
</div>
<p>This instruction will add values from two registers and move them to destination register. We have special case when one of the operands is also the destination register. In this case we can only specify destination register and we don’t need to specify second operand because this operans is value from the destination register.</p>
<p>Addin sufix c to this command will take in consideration the value of the carry flag.</p>
</div>
<div class="section" id="sub">
<h3>SUB<a class="headerlink" href="#sub" title="Permalink to this headline">¶</a></h3>
<p>Basic sytanx of the SUB instruction is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sub 		r0,r1		; r0 = r0 - r1
sub			r0,r0,r1 	; r0= r0 - r1
sbc 		r0,r1		; r0 = r0 - r1 - !C
</pre></div>
</div>
<p>This instruction will add values from two registers and move them to destination register. We have special case when one of the operands is also the destination register. In this case we can only specify destination register and we don’t need to specify second operand because this operans is value from the destination register.</p>
<p>Addin sufix c to this command will take in consideration the value of the carry flag.</p>
</div>
<div class="section" id="rsb">
<h3>RSB<a class="headerlink" href="#rsb" title="Permalink to this headline">¶</a></h3>
<p>This instruction works just like the SUB instruction. Only differenc is that the position of operans are swapped.
Basic sytanx of the RSB instruction is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rsb</span> 		<span class="n">r0</span><span class="p">,</span><span class="n">r1</span>		<span class="p">;</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">r0</span>
<span class="n">rsb</span>			<span class="n">r0</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">r1</span> 		<span class="p">;</span> <span class="n">r0</span><span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">r0</span>
</pre></div>
</div>
</div>
<div class="section" id="bitwise-operation">
<h3>Bitwise operation<a class="headerlink" href="#bitwise-operation" title="Permalink to this headline">¶</a></h3>
<p>Following bitwise operations are supported.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ow">and</span> 				<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span>		<span class="p">;</span><span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">&amp;</span> <span class="n">r2</span>
<span class="n">orr</span>				<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span>		<span class="p">;</span><span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">|</span> <span class="n">r2</span>
<span class="n">eor</span>				<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span>		<span class="p">;</span><span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">^</span> <span class="n">r2</span>
<span class="n">bic</span> 				<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span>		<span class="p">;</span><span class="n">r0</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">r2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="comparison-operations">
<h3>Comparison operations<a class="headerlink" href="#comparison-operations" title="Permalink to this headline">¶</a></h3>
<p>Basic sytanx for comparison instruction is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;&lt;</span><span class="n">cc</span><span class="o">&gt;</span> <span class="n">Rn</span><span class="p">,</span><span class="n">Operand2</span>
</pre></div>
</div>
<p>We can use following operations:</p>
<ul>
<li><b>CMP</b> - Compare (Flags set to result of (Rn − Operand2))</li>
<li><b>CMN</b> - Compare negative (Flags set to result of (Rn + Operand2))</li>
<li><b>TST</b> - bitwise test (Flags set to result of (Rn AND Operand2).)</li>
<li><b>TEQ</b> -  test equivalence (Flags set to result of (Rn EOR Operand2))</li>
</ul>
Comparisons produce no results – they just set condition codes. Ordinary instructions will also set condition codes if the “S” bit is set. The “S” bit is implied for comparison instructions.<p>These instructions update the N, Z, C. For example, the CMP instruction will set the confition codes as follows:</p>
<ul>
        <li> N =1 if the most significant bit of (r1 - r2) is 1, i.e. r2 > r1 </li>
        <li> Z = 1 if (r1 - r2) = 0, i.e. r1 = r2 </li>
        <li> C = 1 if r1 and r2 are both unsigned integers AND (r1 < r2) </li>
        <li> V = 1 if r1 and r2 are both signed integers AND (r1 < r2)</li>
</ul><p>Instructions <strong>TST</strong> and <strong>TEQ</strong> will not affect C flag and this flag will keep previous value.</p>
</div>
</div>
<div class="section" id="conditional-eqecution">
<h2>Conditional eqecution<a class="headerlink" href="#conditional-eqecution" title="Permalink to this headline">¶</a></h2>
<p>The following table lists the available condition codes, their meanings, and the status of the flags that are tested.</p>
<p>| 	Condition Code 	| Meaning (for cmp or subs) 	|	Status of Flags|
|—					|—						|—|
|EQ 					|	Equal 				|Z=1|
|NE 					|Not Equal 				|Z=0|
|GT 					|Signed Greater Than 		|(Z=0) &amp;&amp; (N=V)|
|LT 					|Signed Less Than 			|N!=V|
|GE 					|Signed Greater Than or Equal |N=V|
|LE 					|Signed Less Than or Equal 	|(Z=1) || (N!=V)|
|CS or HS 			|Unsigned Higher or Same (or Carry Set)| 	C=1|
|CC or LO 			|Unsigned Lower (or Carry Clear) |	C=0|
|MI 					|Negative (or Minus) 		|N=1|
|PL 					|Positive (or Plus) 			|N=0|
|AL 	 				|Always executed 	 		|-|
|NV 	 				|Never executed 	 		|-|
|VS 	 				|Signed Overflow 	 		|V=1|
|VC 	 				|No signed Overflow 	 	|V=0|
|HI 	 				|Unsigned Higher 			|(C=1) &amp;&amp; (Z=0)|
|LS 	 				|Unsigned Lower or same 	|(C=0) || (Z=0)|</p>
<p>Syntax: IT{x{y{z}}} cond</p>
<ul class="simple">
<li><p>cond specifies the condition for the first instruction in the IT block</p></li>
<li><p>x specifies the condition switch for the second instruction in the IT block</p></li>
<li><p>y specifies the condition switch for the third instruction in the IT block</p></li>
<li><p>z specifies the condition switch for the fourth instruction in the IT block</p></li>
</ul>
<p>The structure of the IT instruction is “IF-Then-(Else)” and the syntax is a construct of the two letters T and E:</p>
<ul class="simple">
<li><p>IT refers to If-Then (next instruction is conditional)</p></li>
<li><p>ITT refers to If-Then-Then (next 2 instructions are conditional)</p></li>
<li><p>ITE refers to If-Then-Else (next 2 instructions are conditional)</p></li>
<li><p>ITTE refers to If-Then-Then-Else (next 3 instructions are conditional)</p></li>
<li><p>ITTEE refers to If-Then-Then-Else-Else (next 4 instructions are conditional)</p></li>
</ul>
<p>Each instruction inside the IT block must specify a condition suffix that is either the same or logical inverse. This means that if you use ITE, the first and second instruction (If-Then) must have the same condition suffix and the third (Else) must have the logical inverse of the first two. Here are some examples from the ARM reference manual which illustrates this logic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ITTE</span>   <span class="n">NE</span>           <span class="p">;</span> <span class="n">Next</span> <span class="mi">3</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">conditional</span>
<span class="n">ANDNE</span>  <span class="n">R0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">R1</span>   <span class="p">;</span> <span class="n">ANDNE</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">update</span> <span class="n">condition</span> <span class="n">flags</span>
<span class="n">ADDSNE</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="c1">#1   ; ADDSNE updates condition flags</span>
<span class="n">MOVEQ</span>  <span class="n">R2</span><span class="p">,</span> <span class="n">R3</span>       <span class="p">;</span> <span class="n">Conditional</span> <span class="n">move</span>

<span class="n">ITE</span>    <span class="n">GT</span>           <span class="p">;</span> <span class="n">Next</span> <span class="mi">2</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">conditional</span>
<span class="n">ADDGT</span>  <span class="n">R1</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="c1">#55  ; Conditional addition in case the GT is true</span>
<span class="n">ADDLE</span>  <span class="n">R1</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="c1">#48  ; Conditional addition in case the GT is not true</span>

<span class="n">ITTEE</span>  <span class="n">EQ</span>           <span class="p">;</span> <span class="n">Next</span> <span class="mi">4</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">conditional</span>
<span class="n">MOVEQ</span>  <span class="n">R0</span><span class="p">,</span> <span class="n">R1</span>       <span class="p">;</span> <span class="n">Conditional</span> <span class="n">MOV</span>
<span class="n">ADDEQ</span>  <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="c1">#10  ; Conditional ADD</span>
<span class="n">ANDNE</span>  <span class="n">R3</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="c1">#1   ; Conditional AND</span>
<span class="n">BNE</span><span class="o">.</span><span class="n">W</span>  <span class="n">dloop</span>        <span class="p">;</span> <span class="n">Branch</span> <span class="n">instruction</span> <span class="n">can</span> <span class="n">only</span> <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">last</span> <span class="n">instruction</span> <span class="n">of</span> <span class="n">an</span> <span class="n">IT</span> <span class="n">block</span>
</pre></div>
</div>
<p>Wrong syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IT</span>     <span class="n">NE</span>           <span class="p">;</span> <span class="n">Next</span> <span class="n">instruction</span> <span class="ow">is</span> <span class="n">conditional</span>
<span class="n">ADD</span>    <span class="n">R0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">R1</span>   <span class="p">;</span> <span class="n">Syntax</span> <span class="n">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">condition</span> <span class="n">code</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">IT</span> <span class="n">block</span><span class="o">.</span>
</pre></div>
</div>
<p>Here are the conditional codes and theire opposite:</p>
<table>
<thead><tr><th title="Field #1" colspan="2">Condition Code</th>
<th title="Field #2" colspan="2">Opposite</th>
</tr></thead>
<tbody><tr>
<td>Code </td>
<td>	Meaning</td>
<td> 	Code </td>
<td>	Meaning</td>
</tr>
<tr>
<td>EQ 	</td>
<td>Equal </td>
<td>	NE </td>
<td>	 Not Equal</td>
</tr>
<tr>
<td>HS(or CS) </td>
<td>	Unsigned higher or same(or carry set) </td>
<td>	LO(or CC) </td>
<td>	 Unsigned lower (or carry clear)</td>
</tr>
<tr>
<td>MI </td>
<td>	Negative </td>
<td>	PL 	</td>
<td> Positive or Zero</td>
</tr>
<tr>
<td>VS </td>
<td>	Signed Overflow</td>
<td> 	VC 	 </td>
<td>No Signed Overflow</td>
</tr>
<tr>
<td>HI </td>
<td>	Unsigned Higher </td>
<td>	LS 	</td>
<td> Unsigned Lower or Same</td>
</tr>
<tr>
<td>GE </td>
<td>	Signed Greater Than or Equal </td>
<td>	LT 	</td>
<td> Signed Less Than</td>
</tr>
<tr>
<td>GT </td>
<td>	 Signed Greater Than</td>
<td> 	LE </td>
<td>	 Signed Less Than or Equal</td>
</tr>
<tr>
<td>AL(or omitted)</td>
<td> 	 Always Executed </td>
<td colspan="2">	There is no opposite to AL</td>
</tr>
</tbody></table></div>
<div class="section" id="flow-control">
<h2>Flow control<a class="headerlink" href="#flow-control" title="Permalink to this headline">¶</a></h2>
<p>For the flow control we can use following instructions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> 	<span class="n">label</span>	<span class="p">;</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">the</span> <span class="n">label</span> <span class="n">subroutine</span>
<span class="n">bl</span> <span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span> 	<span class="n">label</span>	<span class="p">;</span> <span class="n">coppy</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">instruction</span> <span class="n">to</span> <span class="n">the</span> <span class="n">LR</span> <span class="ow">and</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">the</span> <span class="n">label</span> <span class="n">subroutine</span>
<span class="n">bx</span><span class="o">&lt;</span><span class="n">cond</span><span class="o">&gt;</span>	<span class="n">label</span>	<span class="p">;</span> <span class="n">coppy</span> <span class="n">content</span> <span class="n">of</span> <span class="n">the</span> <span class="n">LR</span> <span class="n">to</span> <span class="n">PC</span> <span class="p">(</span><span class="n">this</span> <span class="ow">is</span> <span class="n">euqal</span> <span class="n">to</span> <span class="k">return</span> <span class="kn">from</span> <span class="nn">subroutine</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-instructions">
<h2>Memory Instructions<a class="headerlink" href="#memory-instructions" title="Permalink to this headline">¶</a></h2>
<p>ARM uses a load-store model for memory access which means that only load/store (LDR and STR) instructions can access memory. While on x86 most instructions are allowed to directly operate on data in memory, on ARM data must be moved from memory into registers before being operated on. This means that incrementing a 32-bit value at a particular memory address on ARM would require three types of instructions (load, increment, and store) to first load the value at a particular address into a register, increment it within the register, and store it back to the memory from the register.</p>
<div class="section" id="addressing-mode">
<h3>Addressing mode<a class="headerlink" href="#addressing-mode" title="Permalink to this headline">¶</a></h3>
<p>ARM arhitecture supports 3 addressing modes:</p>
<ul class="simple">
<li><p>Immediate</p></li>
<li><p>Register</p></li>
<li><p>Scaled register</p></li>
</ul>
<p>These addressing modes can affect the value in the base register in three different ways:</p>
<ul class="simple">
<li><p><strong>Offset</strong>    - The value in the base register is unchanged.</p></li>
<li><p><strong>Pre-indexed</strong>   -  The offset is combined with the value in the base - register, and the base register is updated with this new address before being used to access memory.</p></li>
<li><p><strong>Post-indexed</strong>  -  The value in the base register alone is used to access memory. Then the the offset is combined with the value in the base register, and the base register is updated with this new address after accessing memory.</p></li>
</ul>
</div>
<div class="section" id="load-and-store-instruction">
<h3>Load and Store Instruction<a class="headerlink" href="#load-and-store-instruction" title="Permalink to this headline">¶</a></h3>
<p>Generally, LDR is used to load something from memory into a register, and STR is used to store something from a register to a memory address.</p>
<p><img alt="arm-load-store" src="_images/arm-load-store.png" /></p>
<p>This is how it would look like in a functional assembly program:</p>
<p>At the bottom we have our Literal Pool (a memory area in the same code section to store constants, strings, or offsets that others can reference in a position-independent manner) where we store the memory addresses of var1 and var2 (defined in the data section at the top) using the labels adr_var1 and adr_var2. The first LDR loads the address of var1 into register R0. The second LDR does the same for var2 and loads it to R1. Then we load the value stored at the memory address found in R0 to R2, and store the value found in R2 to the memory address found in R1.</p>
<p>When we load something into a register, the brackets ([ ]) mean: the value found in the register between these brackets is a memory address we want to load something from.</p>
<p>When we store something to a memory location, the brackets ([ ]) mean: the value found in the register between these brackets is a memory address we want to store something to.</p>
<p>This sounds more complicated than it actually is, so here is a visual representation of what’s going on with the memory and the registers when executing the code above in a debugger:</p>
<p><img alt="arm-load-store-animation" src="_images/arm-load-store-gif.gif" /></p>
<p>The use of an equals sign (=) at the start of the second operand of the LDR instruction indicates the use of the LDR pseudo-instruction. This pseuo-instruction is used to load an arbitrary 32-bit constant value into a register with a single instruction despite the fact that the ARM instruction set only supports immediate values in a much smaller range.</p>
<p>If the value after the = is known by the assembler and fits in with the allowed range of an immediate value for the MOV or MVN instruction then a MOV or MVN instruction is generated. Otherwise the constant value is put into the literal pool, and a PC-relative LDR instruction is used to load the value into the register.</p>
<p>###Offset form: Immediate value as the offset</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rb</span><span class="p">,</span> <span class="n">imm</span><span class="p">]</span>
<span class="n">LDR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rc</span><span class="p">,</span> <span class="n">imm</span><span class="p">]</span>
</pre></div>
</div>
<p>Here we use an immediate (integer) as an offset. This value is added or subtracted from the base register (R1 in the example below) to access data at an offset known at compile time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="n">adr_var1</span>  <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">of</span> <span class="n">var1</span> <span class="n">via</span> <span class="n">label</span> <span class="n">adr_var1</span> <span class="n">into</span> <span class="n">R0</span>
	<span class="n">ldr</span> <span class="n">r1</span><span class="p">,</span> <span class="n">adr_var2</span>  <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">of</span> <span class="n">var2</span> <span class="n">via</span> <span class="n">label</span> <span class="n">adr_var2</span> <span class="n">into</span> <span class="n">R1</span>
	<span class="n">ldr</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r0</span><span class="p">]</span>      <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">value</span> <span class="p">(</span><span class="mh">0x03</span><span class="p">)</span> <span class="n">at</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">R0</span> <span class="n">to</span> <span class="n">register</span> <span class="n">R2</span>
	<span class="nb">str</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">,</span> <span class="c1">#2]  @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 plus 2. Base register (R1) unmodified.</span>
	<span class="nb">str</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">,</span> <span class="c1">#4]! @ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 plus 4. Base register (R1) modified: R1 = R1+4</span>
	<span class="n">ldr</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="c1">#4  @ address mode: post-indexed. Load the value at memory address found in R1 to register R3. Base register (R1) modified: R1 = R1+4</span>
</pre></div>
</div>
<p>Visual representation of above code:</p>
<p><img alt="arm_load-store-immediate-offset" src="_images/arm-load-store-offset-im.gif" /></p>
</div>
<div class="section" id="offset-form-register-as-the-offset">
<h3>Offset form: Register as the offset.<a class="headerlink" href="#offset-form-register-as-the-offset" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rb</span><span class="p">,</span> <span class="n">Rc</span><span class="p">]</span>
<span class="n">LDR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rb</span><span class="p">,</span> <span class="n">Rc</span><span class="p">]</span>
</pre></div>
</div>
<p>This offset form uses a register as an offset. An example usage of this offset form is when your code wants to access an array where the index is computed at run-time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	ldr r0, adr_var1  @ load the memory address of var1 via label adr_var1 to R0 
    ldr r1, adr_var2  @ load the memory address of var2 via label adr_var2 to R1 
    ldr r2, [r0]      @ load the value (0x03) at memory address found in R0 to R2
    str r2, [r1, r2]  @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register unmodified.   
    @pre-index and post-indexed don&#39;t work in .thumb mode
    str r2, [r1, r2]! @ address mode: pre-indexed. Store value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register modified: R1 = R1+R2. 
    ldr r3, [r1], r2  @ address mode: post-indexed. Load value at memory address found in R1 to register R3. Then modify base register: R1 = R1+R2.
</pre></div>
</div>
<p>Visual representation of the above code:</p>
<p><img alt="arm_load-store-register-offset" src="_images/arm-load-store-offset-ref.gif" /></p>
</div>
<div class="section" id="offset-form-scaled-register-as-the-offset">
<h3>Offset form: Scaled register as the offset<a class="headerlink" href="#offset-form-scaled-register-as-the-offset" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rb</span><span class="p">,</span> <span class="n">Rc</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">shifter</span><span class="o">&gt;</span><span class="p">]</span>
<span class="n">STR</span>    <span class="n">Ra</span><span class="p">,</span> <span class="p">[</span><span class="n">Rb</span><span class="p">,</span> <span class="n">Rc</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">shifter</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>The third offset form has a scaled register as the offset. In this case, Rb is the base register and Rc is an immediate offset (or a register containing an immediate value) left/right shifted (<shifter>) to scale the immediate.
This means that the barrel shifter is used to scale the offset. An example usage of this offset form would be for loops to iterate over an array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="n">adr_var1</span>         <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">of</span> <span class="n">var1</span> <span class="n">via</span> <span class="n">label</span> <span class="n">adr_var1</span> <span class="n">to</span> <span class="n">R0</span>
    <span class="n">ldr</span> <span class="n">r1</span><span class="p">,</span> <span class="n">adr_var2</span>         <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">of</span> <span class="n">var2</span> <span class="n">via</span> <span class="n">label</span> <span class="n">adr_var2</span> <span class="n">to</span> <span class="n">R1</span>
    <span class="n">ldr</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r0</span><span class="p">]</span>             <span class="o">@</span> <span class="n">load</span> <span class="n">the</span> <span class="n">value</span> <span class="p">(</span><span class="mh">0x03</span><span class="p">)</span> <span class="n">at</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">R0</span> <span class="n">to</span> <span class="n">R2</span>
    <span class="nb">str</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">LSL</span><span class="c1">#2]  @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register (R1) unmodified.</span>
    <span class="nb">str</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">LSL</span><span class="c1">#2]! @ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register modified: R1 = R1 + R2&lt;&lt;2</span>
    <span class="n">ldr</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r2</span><span class="p">,</span> <span class="n">LSL</span><span class="c1">#2  @ address mode: post-indexed. Load value at memory address found in R1 to the register R3. Then modifiy base register: R1 = R1 + R2&lt;&lt;2</span>
</pre></div>
</div>
<p>The first STR operation uses the offset address mode and stores the value found in R2 at the memory location calculated from [r1, r2, LSL#2], which means that it
takes the value in R1 as a base (in this case, R1 contains the memory address of var2), then it takes the value in R2 (0x3), and shifts it left by 2.
The picture below is an attempt to visualize how the memory location is calculated with [r1, r2, LSL#2].</p>
<p><img alt="arm_load-store-register-offset-shift" src="_images/arm-load-store-barrel-shift.png" /></p>
</div>
</div>
</div>
<div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p><a class="reference external" href="http://www.peter-cockerell.net/aalp/html/frames.html">Peter Cockerell Book</a></p></li>
<li><p><a class="reference external" href="https://azeria-labs.com/writing-arm-assembly-part-1/">Azeria Labs</a></p></li>
</ol>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright semir-t.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>